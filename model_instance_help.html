<!DOCTYPE html> 
<html lang="en" dir="ltr">   
<head>     
<meta charset="utf-8">
<link rel="stylesheet" href="styles/atom-one-light.css">     
<link href="https://fonts.googleapis.com/css?family=Montserrat:Light|Open+Sans|Nunito+Sans"
rel="stylesheet">     
<link rel="stylesheet" href="master.css">
<title>Model Instance Help</title>   
</head>   
<body>     
<div class="main-container">       
<h2 class="second-heading">Model Instance Help</h2>
           
<pre><code class="language-python">
Help on Tag in module organizer.models object:

class Tag(django.db.models.base.Model)
  Tag(id, name, slug)

  Method resolution order:
      Tag
      django.db.models.base.Model
      builtins.object

  Methods defined here:

  __str__(self)
      Return str(self).

  get_absolute_url(self)

  ----------------------------------------------------------------------
  Data descriptors defined here:

  blog_posts

  startup_set

  ----------------------------------------------------------------------
  Data and other attributes defined here:

  DoesNotExist = class 'organizer.models.DoesNotExist'
      The requested object does not exist.

  MultipleObjectsReturned = class 'organizer.models.MultipleObjectsReturned'
      The query returned multiple objects when only one was expected.

  objects = django.db.models.manager.Manager object


  ----------------------------------------------------------------------
  Methods inherited from django.db.models.base.Model:

  __eq__(self, other)
      Return self==value.

  __hash__(self)
      Return hash(self).

  __init__(self, *args, **kwargs)
      Initialize self.  See help(type(self)) for accurate signature.

  __ne__(self, other)
      Return self!=value.

  __reduce__(self)
      Provides pickling support. Normally, this just dispatches to Python's
      standard handling. However, for models with deferred field loading, we
      need to do things manually, as they're dynamically created classes and
      only module-level classes can be pickled by the default path.

  __repr__(self)
      Return repr(self).

  __setstate__(self, state)

  clean(self)
      Hook for doing any extra model-wide validation after clean() has been
      called on every field by self.clean_fields. Any ValidationError raised
      by this method will not be associated with a particular field; it will
      have a special-case association with the field defined by 
      NON_FIELD_ERRORS.

  clean_fields(self, exclude=None)
      Cleans all fields and raises a ValidationError containing a dict
      of all validation errors if any occur.

  date_error_message(self, lookup_type, field_name, unique_for)

  delete(self, using=None)

  full_clean(self, exclude=None, validate_unique=True)
      Calls clean_fields, clean, and validate_unique, on the model,
      and raises a ``ValidationError`` for any errors that occurred.

  get_deferred_fields(self)
      Returns a set containing names of deferred fields for this instance.

  prepare_database_save(self, field)

  refresh_from_db(self, using=None, fields=None, **kwargs)
      Reloads field values from the database.

      By default, the reloading happens from the database this instance was
      loaded from, or by the read router if this instance wasn't loaded from
      any database. The using parameter will override the default.

      Fields can be used to specify which fields to reload. The fields
      should be an iterable of field attnames. If fields is None, then
      all non-deferred fields are reloaded.

      When accessing deferred fields of an instance, the deferred loading
      of the field will call this method.

  save(self, force_insert=False, force_update=False, using=None, 
       update_fields=None)
      Saves the current instance. Override this in a subclass if you want to
      control the saving process.

      The 'force_insert' and 'force_update' parameters can be used to insist
      that the "save" must be an SQL insert or update (or equivalent for
      non-SQL backends), respectively. Normally, they should not be set.

  save_base(self, raw=False, force_insert=False, force_update=False, 
            using=None, update_fields=None)
      Handles the parts of saving which should be done only once per save,
      yet need to be done in raw saves, too. This includes some sanity
      checks and signal sending.

      The 'raw' argument is telling save_base not to save any parent
      models and not to do any changes to the values before save. This
      is used by fixture loading.

  serializable_value(self, field_name)
      Returns the value of the field name for this instance. If the field is
      a foreign key, returns the id value, instead of the object. If there's
      no Field object with this name on the model, the model attribute's
      value is returned directly.

      Used to serialize a field's value (in the serializer, or form output,
      for example). Normally, you would just access the attribute directly
      and not use this method.

  unique_error_message(self, model_class, unique_check)

  validate_unique(self, exclude=None)
      Checks unique constraints on the model and raises ``ValidationError``
      if any failed.

  ----------------------------------------------------------------------
  Class methods inherited from django.db.models.base.Model:

  check(**kwargs) from django.db.models.base.ModelBase

  from_db(db, field_names, values) from django.db.models.base.ModelBase

  ----------------------------------------------------------------------
  Data descriptors inherited from django.db.models.base.Model:

  __dict__
      dictionary for instance variables (if defined)

  __weakref__
      list of weak references to the object (if defined)

  pk
              </code></pre>
    </div>

    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
